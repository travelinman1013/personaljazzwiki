---
/**
 * Artist Detail Page - SSR with D1 Database
 * Fetches artist data from Cloudflare D1 instead of content collection
 */
import WikiArticle from '../../layouts/WikiArticle.astro';
import ConnectionGraph from '../../components/artist/ConnectionGraph.astro';
import WWOZPlays from '../../components/artist/WWOZPlays.astro';
import connectionsIndex from '../../data/connections-index.json';

// Get the slug from params
const { slug } = Astro.params;

if (!slug) {
  return Astro.redirect('/artists');
}

// Get D1 database from Cloudflare runtime
const runtime = Astro.locals.runtime;
const db = runtime?.env?.DB;

if (!db) {
  // Fallback for local dev without D1 - redirect to artist list
  console.error('D1 database not available');
  return Astro.redirect('/artists');
}

// Fetch artist from D1
const artistRow = await db
  .prepare('SELECT * FROM artists WHERE slug = ?')
  .bind(slug)
  .first();

if (!artistRow) {
  // Artist not found - redirect to 404 or artists list
  return Astro.redirect('/artists');
}

// Parse JSON fields from D1
const genres = artistRow.genres ? JSON.parse(artistRow.genres) : [];
const instruments = artistRow.instruments ? JSON.parse(artistRow.instruments) : [];
const roles = artistRow.roles ? JSON.parse(artistRow.roles) : [];
const spotifyData = artistRow.spotify_data ? JSON.parse(artistRow.spotify_data) : null;
const audioProfile = artistRow.audio_profile ? JSON.parse(artistRow.audio_profile) : null;
const externalUrls = artistRow.external_urls ? JSON.parse(artistRow.external_urls) : null;
const musicalConnections = artistRow.musical_connections ? JSON.parse(artistRow.musical_connections) : null;
const discographySummary = artistRow.discography_summary ? JSON.parse(artistRow.discography_summary) : null;
const socialLinks = artistRow.social_links ? JSON.parse(artistRow.social_links) : null;

// Parse new fields for origin, birth_place, and research sources
const origin = artistRow.origin || null;
const birthPlace = artistRow.birth_place || null;
let researchSources: string[] = artistRow.research_sources ? JSON.parse(artistRow.research_sources) : [];

// Build the data object that Infobox expects
const data: Record<string, unknown> = {
  title: artistRow.title,
  artist_type: artistRow.artist_type,
  birth_date: artistRow.birth_date,
  death_date: artistRow.death_date,
  origin,
  birth_place: birthPlace,
  genres,
  instruments,
  roles,
  spotify_data: spotifyData,
  audio_profile: audioProfile,
  external_urls: externalUrls,
  musical_connections: musicalConnections,
  discography_summary: discographySummary,
  social_links: socialLinks,
  career_span: artistRow.career_span,
  is_active: artistRow.is_active !== 0,
  primary_role: artistRow.primary_role,
  // For portrait in Infobox
  image_path: artistRow.image_filename ? `/portraits/${artistRow.image_filename}` : undefined,
  // Infobox also checks infobox.background for artist type styling
  infobox: {
    background: artistRow.artist_type,
    image: artistRow.image_filename,
  },
};

// Get bio HTML content
let htmlContent = artistRow.bio_html || '';

// Remove redundant Quick Info section (data is in infobox)
htmlContent = htmlContent.replace(/<h2[^>]*>Quick Info<\/h2>\s*<ul>[\s\S]*?<\/ul>/gi, '');

// Extract research sources from bio_html (fallback if not in DB)
if (researchSources.length === 0) {
  const sourcesMatch = htmlContent.match(/<p><em>Sources:[\s\S]*?<\/em><\/p>/i);
  if (sourcesMatch) {
    const hrefRegex = /href="([^"]+)"/g;
    let match;
    while ((match = hrefRegex.exec(sourcesMatch[0])) !== null) {
      const url = match[1];
      if (url.startsWith('http://') || url.startsWith('https://')) {
        researchSources.push(url);
      }
    }
  }
}

// Remove Perplexity attribution and source lines from body (will show in References section)
htmlContent = htmlContent.replace(/<p><em>Enhanced with Perplexity AI research<\/em><\/p>/gi, '');
htmlContent = htmlContent.replace(/<p><em>Sources:[\s\S]*?<\/em><\/p>/gi, '');

// Process wiki links in bio_html: [[Artist Name|Display Text]] -> HTML links
// First, we need to get all artist slugs for red link detection
const allArtistsResult = await db
  .prepare('SELECT slug FROM artists')
  .all();
const artistSlugs = new Set((allArtistsResult.results || []).map((r: any) => r.slug));

// Convert wiki links [[artist_name|Display Name]] to HTML links
htmlContent = htmlContent.replace(
  /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
  (match: string, pageName: string, displayName: string) => {
    const linkSlug = pageName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    const text = displayName || pageName;
    if (artistSlugs.has(linkSlug)) {
      return `<a href="/artists/${linkSlug}" class="wiki-link">${text}</a>`;
    } else {
      // Plain text for non-existent artists - will auto-link when artist is added
      return `<span class="wiki-link-missing">${text}</span>`;
    }
  }
);

// Add IDs to all h2 headings for TOC navigation (if not already present)
htmlContent = htmlContent.replace(/<h2>([^<]+)<\/h2>/gi, (match: string, text: string) => {
  const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
  return `<h2 id="${id}">${text}</h2>`;
});

// Extract h2 headings for table of contents
const headings: { id: string; text: string }[] = [];
const headingRegex = /<h2 id="([^"]+)">([^<]+)<\/h2>/gi;
let headingMatch;
while ((headingMatch = headingRegex.exec(htmlContent)) !== null) {
  headings.push({ id: headingMatch[1], text: headingMatch[2] });
}

// Add References to TOC if we have sources
if (researchSources.length > 0) {
  headings.push({ id: 'references', text: 'References' });
}

// Get title with fallback
const title = artistRow.title || slug.replace(/-/g, ' ').replace(/\b\w/g, (c: string) => c.toUpperCase());

// Get connections for this artist from the static index
const artistConnections = {
  forward: (connectionsIndex as any).forward?.[slug] || {},
  reverse: (connectionsIndex as any).reverse?.[slug] || {},
};

// Check if artist has any connections
const hasConnections =
  (artistConnections.forward?.collaborators?.length > 0) ||
  (artistConnections.forward?.influenced?.length > 0) ||
  (artistConnections.forward?.mentors?.length > 0) ||
  (artistConnections.reverse?.collaboratedWith?.length > 0) ||
  (artistConnections.reverse?.influencedBy?.length > 0) ||
  (artistConnections.reverse?.mentoredBy?.length > 0);

// Get name to slug mapping for connection graph navigation
const nameToSlug = (connectionsIndex as any).nameToSlug || {};

// Check if bio_html already has a Musical Connections section
// If so, the graph will be rendered as a subsection (no h2)
const bioHasMusicalConnections = /<h2[^>]*>Musical Connections<\/h2>/i.test(htmlContent);

// Set cache headers for stale-while-revalidate caching
Astro.response.headers.set(
  'Cache-Control',
  'public, max-age=60, stale-while-revalidate=86400'
);
---

<WikiArticle title={title} data={data} headings={headings} connections={artistConnections} artistSlug={slug}>
  <Fragment set:html={htmlContent} />

  {/* References Section - Perplexity research sources */}
  {researchSources.length > 0 && (
    <section class="references-section">
      <h2 id="references">References</h2>
      <ol class="references-list">
        {researchSources.map((url, i) => {
          let displayName = url;
          try {
            displayName = new URL(url).hostname.replace('www.', '');
          } catch {
            // Keep original if URL parsing fails
          }
          return (
            <li id={`ref-${i + 1}`}>
              <a href={url} target="_blank" rel="noopener noreferrer">{displayName}</a>
            </li>
          );
        })}
      </ol>
    </section>
  )}

  {/* WWOZ Plays Section */}
  <WWOZPlays artistSlug={slug} artistName={title} />

  {/* Connection Graph - only if connections exist */}
  {/* If bio already has Musical Connections section, render graph as subsection */}
  {hasConnections && (
    <ConnectionGraph
      artistSlug={slug}
      artistName={title}
      connections={artistConnections}
      nameToSlug={nameToSlug}
      showHeading={!bioHasMusicalConnections}
    />
  )}
</WikiArticle>

<style is:global>
  /* Style wiki links - use CSS variables for theming */
  .wiki-link {
    color: var(--color-link);
    text-decoration: none;
  }

  .wiki-link:hover {
    text-decoration: underline;
    color: var(--color-link-hover);
  }

  /* Non-existent artists - plain text, slightly muted */
  .wiki-link-missing {
    color: var(--color-text);
  }

  /* Hide broken images (portraits that don't exist) */
  .article-content img {
    display: none;
  }

  /* References list styling */
  .references-list {
    list-style-position: inside;
    padding-left: 0;
    margin: 1rem 0;
  }

  .references-list li {
    padding: 0.25rem 0;
    color: var(--color-text-secondary);
    word-break: break-all;
  }

  .references-list a {
    color: var(--color-link);
    text-decoration: none;
  }

  .references-list a:hover {
    text-decoration: underline;
    color: var(--color-link-hover);
  }
</style>
