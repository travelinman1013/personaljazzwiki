---
/**
 * Artist Detail Page - SSR with D1 Database
 * Fetches artist data from Cloudflare D1 instead of content collection
 */
import WikiArticle from '../../layouts/WikiArticle.astro';
import ConnectionGraph from '../../components/artist/ConnectionGraph.astro';
import WWOZPlays from '../../components/artist/WWOZPlays.astro';
import connectionsIndex from '../../data/connections-index.json';

// Get the slug from params
const { slug } = Astro.params;

if (!slug) {
  return Astro.redirect('/artists');
}

// Get D1 database from Cloudflare runtime
const runtime = Astro.locals.runtime;
const db = runtime?.env?.DB;

if (!db) {
  // Fallback for local dev without D1 - redirect to artist list
  console.error('D1 database not available');
  return Astro.redirect('/artists');
}

// Fetch artist from D1
const artistRow = await db
  .prepare('SELECT * FROM artists WHERE slug = ?')
  .bind(slug)
  .first();

if (!artistRow) {
  // Artist not found - redirect to 404 or artists list
  return Astro.redirect('/artists');
}

// Parse JSON fields from D1
const genres = artistRow.genres ? JSON.parse(artistRow.genres) : [];
const instruments = artistRow.instruments ? JSON.parse(artistRow.instruments) : [];
const spotifyData = artistRow.spotify_data ? JSON.parse(artistRow.spotify_data) : null;
const audioProfile = artistRow.audio_profile ? JSON.parse(artistRow.audio_profile) : null;
const externalUrls = artistRow.external_urls ? JSON.parse(artistRow.external_urls) : null;
const musicalConnections = artistRow.musical_connections ? JSON.parse(artistRow.musical_connections) : null;

// Build the data object that Infobox expects
const data: Record<string, unknown> = {
  title: artistRow.title,
  artist_type: artistRow.artist_type,
  birth_date: artistRow.birth_date,
  death_date: artistRow.death_date,
  genres,
  instruments,
  spotify_data: spotifyData,
  audio_profile: audioProfile,
  external_urls: externalUrls,
  musical_connections: musicalConnections,
  // For portrait in Infobox
  image_path: artistRow.image_filename ? `/portraits/${artistRow.image_filename}` : undefined,
  // Infobox also checks infobox.background for artist type styling
  infobox: {
    background: artistRow.artist_type,
    image: artistRow.image_filename,
  },
};

// Get bio HTML content
let htmlContent = artistRow.bio_html || '';

// Process wiki links in bio_html: [[Artist Name|Display Text]] -> HTML links
// First, we need to get all artist slugs for red link detection
const allArtistsResult = await db
  .prepare('SELECT slug FROM artists')
  .all();
const artistSlugs = new Set((allArtistsResult.results || []).map((r: any) => r.slug));

// Convert wiki links [[artist_name|Display Name]] to HTML links
htmlContent = htmlContent.replace(
  /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
  (match: string, pageName: string, displayName: string) => {
    const linkSlug = pageName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    const text = displayName || pageName;
    if (artistSlugs.has(linkSlug)) {
      return `<a href="/artists/${linkSlug}" class="wiki-link">${text}</a>`;
    } else {
      // Plain text for non-existent artists - will auto-link when artist is added
      return `<span class="wiki-link-missing">${text}</span>`;
    }
  }
);

// Add IDs to all h2 headings for TOC navigation (if not already present)
htmlContent = htmlContent.replace(/<h2>([^<]+)<\/h2>/gi, (match: string, text: string) => {
  const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
  return `<h2 id="${id}">${text}</h2>`;
});

// Extract h2 headings for table of contents
const headings: { id: string; text: string }[] = [];
const headingRegex = /<h2 id="([^"]+)">([^<]+)<\/h2>/gi;
let headingMatch;
while ((headingMatch = headingRegex.exec(htmlContent)) !== null) {
  headings.push({ id: headingMatch[1], text: headingMatch[2] });
}

// Get title with fallback
const title = artistRow.title || slug.replace(/-/g, ' ').replace(/\b\w/g, (c: string) => c.toUpperCase());

// Get connections for this artist from the static index
const artistConnections = {
  forward: (connectionsIndex as any).forward?.[slug] || {},
  reverse: (connectionsIndex as any).reverse?.[slug] || {},
};

// Check if artist has any connections
const hasConnections =
  (artistConnections.forward?.collaborators?.length > 0) ||
  (artistConnections.forward?.influenced?.length > 0) ||
  (artistConnections.forward?.mentors?.length > 0) ||
  (artistConnections.reverse?.collaboratedWith?.length > 0) ||
  (artistConnections.reverse?.influencedBy?.length > 0) ||
  (artistConnections.reverse?.mentoredBy?.length > 0);

// Get name to slug mapping for connection graph navigation
const nameToSlug = (connectionsIndex as any).nameToSlug || {};

// Set cache headers for stale-while-revalidate caching
Astro.response.headers.set(
  'Cache-Control',
  'public, max-age=60, stale-while-revalidate=86400'
);
---

<WikiArticle title={title} data={data} headings={headings}>
  <Fragment set:html={htmlContent} />

  {/* WWOZ Plays Section */}
  <WWOZPlays artistSlug={slug} artistName={title} />

  {/* Connection Graph - only if connections exist */}
  {hasConnections && (
    <ConnectionGraph
      artistSlug={slug}
      artistName={title}
      connections={artistConnections}
      nameToSlug={nameToSlug}
    />
  )}
</WikiArticle>

<style is:global>
  /* Style wiki links - use CSS variables for theming */
  .wiki-link {
    color: var(--color-link);
    text-decoration: none;
  }

  .wiki-link:hover {
    text-decoration: underline;
    color: var(--color-link-hover);
  }

  /* Non-existent artists - plain text, slightly muted */
  .wiki-link-missing {
    color: var(--color-text);
  }

  /* Hide broken images (portraits that don't exist) */
  .article-content img {
    display: none;
  }

  /* References list styling */
  .references-list {
    list-style-position: inside;
    padding-left: 0;
    margin: 1rem 0;
  }

  .references-list li {
    padding: 0.25rem 0;
    color: var(--color-text-secondary);
    word-break: break-all;
  }

  .references-list a {
    color: var(--color-link);
    text-decoration: none;
  }

  .references-list a:hover {
    text-decoration: underline;
    color: var(--color-link-hover);
  }
</style>
