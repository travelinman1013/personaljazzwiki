---
import { getCollection } from 'astro:content';
import WikiArticle from '../../layouts/WikiArticle.astro';
import { marked } from 'marked';
import ConnectionGraph from '../../components/artist/ConnectionGraph.astro';
import WWOZPlays from '../../components/artist/WWOZPlays.astro';
import connectionsIndex from '../../data/connections-index.json';

export async function getStaticPaths() {
  const artists = await getCollection('artists');
  // Build Set of all artist slugs for red link detection
  const artistSlugs = artists.map(a => a.id);

  return artists.map((artist) => ({
    params: { slug: artist.id },
    props: { artist, artistSlugs },
  }));
}

const { artist, artistSlugs } = Astro.props;
// Convert to Set for O(1) lookup
const artistSlugSet = new Set(artistSlugs as string[]);
const { data } = artist;

// Get the raw markdown body
const rawBody = data._rawBody as string | undefined;

// Process the markdown content
let htmlContent = '';
let researchSources: string[] = [];
if (rawBody) {
  // Remove the first image reference (it's usually a portrait at the top)
  let processedBody = rawBody.replace(/^!\[.*?\]\(.*?\)\s*/m, '');

  // Remove the first h1 heading (title is already in layout)
  processedBody = processedBody.replace(/^#\s+.+\n/m, '');

  // Convert wiki links [[artist_name|Display Name]] to HTML links
  // Non-existent artists render as plain text (will become links when added)
  processedBody = processedBody.replace(
    /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
    (match, pageName, displayName) => {
      const slug = pageName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
      const text = displayName || pageName;
      if (artistSlugSet.has(slug)) {
        return `<a href="/artists/${slug}" class="wiki-link">${text}</a>`;
      } else {
        // Plain text for non-existent artists - will auto-link when artist is added
        return `<span class="wiki-link-missing">${text}</span>`;
      }
    }
  );

  // Extract research sources from markdown (preserves order: Source1=index 0, etc.)
  const sourcesMatch = processedBody.match(/\*Sources:\s*(.+?)\*/);
  if (sourcesMatch) {
    const sourceLinksRegex = /\[Source\d+\]\(([^)]+)\)/g;
    let match;
    while ((match = sourceLinksRegex.exec(sourcesMatch[1])) !== null) {
      researchSources.push(match[1]); // Extract URL
    }
  }

  // Remove enhancement text and sources from body
  processedBody = processedBody.replace(/\*Enhanced with Perplexity AI research\*\s*\n?/g, '');
  processedBody = processedBody.replace(/\*Sources:.*\*\s*\n?/g, '');

  // Convert markdown to HTML
  htmlContent = await marked.parse(processedBody, {
    gfm: true,
    breaks: false,
  });

  // Add IDs to all h2 headings for TOC navigation
  htmlContent = htmlContent.replace(/<h2>([^<]+)<\/h2>/gi, (match, text) => {
    const id = text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    return `<h2 id="${id}">${text}</h2>`;
  });

  // Build References HTML section
  let referencesHtml = '';
  if (researchSources.length > 0) {
    referencesHtml = `
<h2 id="references">References</h2>
<ol class="references-list">
${researchSources.map((source, i) => {
    const isUrl = source.startsWith('http://') || source.startsWith('https://');
    if (isUrl) {
      return `  <li id="ref-${i+1}"><a href="${source}" target="_blank" rel="noopener noreferrer">${source}</a></li>`;
    }
    return `  <li id="ref-${i+1}">${source}</li>`;
  }).join('\n')}
</ol>
`;
  }

  // Inject References section before External Links
  if (htmlContent.includes('<h2 id="external-links">')) {
    htmlContent = htmlContent.replace(
      /<h2 id="external-links">/i,
      `${referencesHtml}<h2 id="external-links">`
    );
  } else if (htmlContent.includes('<h2>External Links</h2>')) {
    htmlContent = htmlContent.replace(
      /<h2>External Links<\/h2>/i,
      `${referencesHtml}<h2 id="external-links">External Links</h2>`
    );
  } else if (referencesHtml) {
    // No External Links section, append References at the end
    htmlContent += referencesHtml;
  }
}

// Extract h2 headings for table of contents
const headings: { id: string; text: string }[] = [];
const headingRegex = /<h2 id="([^"]+)">([^<]+)<\/h2>/gi;
let headingMatch;
while ((headingMatch = headingRegex.exec(htmlContent)) !== null) {
  headings.push({ id: headingMatch[1], text: headingMatch[2] });
}

// Get title with fallback
const title = (data.title as string) || artist.id.replace(/-/g, ' ').replace(/\b\w/g, (c: string) => c.toUpperCase());

// Get connections for this artist
const artistConnections = {
  forward: (connectionsIndex as any).forward?.[artist.id] || {},
  reverse: (connectionsIndex as any).reverse?.[artist.id] || {},
};

// Check if artist has any connections
const hasConnections =
  (artistConnections.forward?.collaborators?.length > 0) ||
  (artistConnections.forward?.influenced?.length > 0) ||
  (artistConnections.forward?.mentors?.length > 0) ||
  (artistConnections.reverse?.collaboratedWith?.length > 0) ||
  (artistConnections.reverse?.influencedBy?.length > 0) ||
  (artistConnections.reverse?.mentoredBy?.length > 0);

// Get name to slug mapping for connection graph navigation
const nameToSlug = (connectionsIndex as any).nameToSlug || {};
---

<WikiArticle title={title} data={data} headings={headings}>
  <Fragment set:html={htmlContent} />

  {/* WWOZ Plays Section */}
  <WWOZPlays artistSlug={artist.id} artistName={title} />

  {/* Connection Graph - only if connections exist */}
  {hasConnections && (
    <ConnectionGraph
      artistSlug={artist.id}
      artistName={title}
      connections={artistConnections}
      nameToSlug={nameToSlug}
    />
  )}
</WikiArticle>

<style is:global>
  /* Style wiki links - use CSS variables for theming */
  .wiki-link {
    color: var(--color-link);
    text-decoration: none;
  }

  .wiki-link:hover {
    text-decoration: underline;
    color: var(--color-link-hover);
  }

  /* Non-existent artists - plain text, slightly muted */
  .wiki-link-missing {
    color: var(--color-text);
  }

  /* Hide broken images (portraits that don't exist) */
  .article-content img {
    display: none;
  }

  /* References list styling */
  .references-list {
    list-style-position: inside;
    padding-left: 0;
    margin: 1rem 0;
  }

  .references-list li {
    padding: 0.25rem 0;
    color: var(--color-text-secondary);
    word-break: break-all;
  }

  .references-list a {
    color: var(--color-link);
    text-decoration: none;
  }

  .references-list a:hover {
    text-decoration: underline;
    color: var(--color-link-hover);
  }
</style>
